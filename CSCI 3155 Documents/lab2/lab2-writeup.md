#Lab 2 Write-up Answers

##Problem 2

###2a) 
Describe the language defined by the following grammar:

S ::= A B A

A ::= a | a A

B ::= ε | b B c | B B

Answer: The grammar creates a string composed of the characters a, b, and c. It first prints the character "a" out X number of times, then prints the characters "b" then "c" Y number of times, then the character "a" Z number of times. For "b" and "c", it prints them both the same number of times. An example string could be "aaaaabcbcbcaaaaa".

###2b) 
Consider the following grammar:

S ::= A a B b

A ::= A b | b

B ::= a B | a

**1. baab**
```Markdown
S ::= AaBb
   => baBb    <- Because A can go to just "b"
   => baab    <- Because B can go to just "a"
   
We can create this string because it fits all the grammar rules.   
```
**2. bbbab**
```Markdown
S ::= AaBb
   => AbaBb   <- A can go to "Ab"
   => AbbaBb  <- A can go to "Ab" again
   => bbbaBb  <- A goes to "b" because we need 3 "b"'s
   => bbbaab  <- B goes to "a"

You can't create the string "bbbab" using this grammar, since there will be an extra "a" produced by the grammar.
```
**3. bbaaaaa**
```Markdown
S ::= AaBb
   => AbaBb   <- A goes to "Ab"
   => bbaBb   <- A goes to  just "b"
   => bbaaBb  <- Continue re-iterating B until we have all the "a"'s we need.
   => bbaaaBb
   => bbaaaaBb
   => bbaaaaab
   
You can't create the string "bbaaaaa" because the grammar has to end with a "b", and there is no way to get rid of a character.
   ```
**4. bbaab**
```Markdown
S ::= AaBb
   => AbaBb
   => bbaBb
   => bbaab
 
We can create this string because it fits all the grammar rules.    
```

###2c) 
Consider the following grammar:

S ::= a S c B | A | b

A ::= c A | c

B ::= d | A

**1. abcd**
```Markdown
      S
   / / \ \
  a S  c  B
    |     |
    b     d

We can create this string because it fits all the grammar rules.    
```

**2. acccbd**
```Markdown
      S
   / / \ \
  a S  c  B
    |     |
    A     d
   / \
  c   A
      |
      c

We can't create this string because there is no way to fit the character b into the grammar rules.   
```

**3. acccbcc**
```Markdown
      S
   / / \ \
  a S  c  B
    |     |
    A     A
   / \   / \
  c   A c   A
      |     |
      c     c

We can't create this string because there is no way to fit the character b into the grammar rules.   
```

**4. acd**
```Markdown
      S
   / / \ \
  a S  c  B
          |
          d

We can't create this string because there is no way to get replace S with an empty string in the grammar rules.   
```

**5. accc**
```Markdown
      S
   / / \ \
  a S  c  B
    |     |
    A     A
    |     |
    c     c

We can create this string because it fits into the grammar rules.   
```
###2d)
Consider the following grammar:
Show that this grammar is ambiguous.
A ::= a | b | A⊕A
```Markdown
      A                  A
     / \                / \
    A   A              A   A
   / \   |             |  / \
  a   b  a             a b   a


With the sample string "aba" we can show two parse trees, and because there are two parse trees, it is ambiguous.
```

###2e)
Let us ascribe a semantics to the syntactic objects A specified in the above grammar from part d. In particular, let us write

```Markdown
A1 ⇓ n1   A2 ⇓ n2             
------------------         ------    ------   
A1 ⊕ A2 ⇓ n1 ⊕ n2          a ⇓ 1     b ⇓ 0
```

for the judgment form that should mean A has a total n a symbols where n is the metavariable for natural numbers. Define this judgment form via a set of inference rules.

##Problem 3

###3a
e :: = operand | e operator operand

e ::= operand esuffix
esuffix ::= operator operand esuffix | ε

i. The expression generated by both grammars are:

   operand(operator operand)*
   
We see that both expressions need to start with a operand, and is followed by operators and operands. Each operand is followed by a operator and each operand has to be followed by a operator. The expressions generated by this grammar is infinite, as in the strings can go on indefinitely. The expression can also just be a lone operand too. The rule stated above states that a operand starts the expression, and the operand is then followed by 0 or more (operator operand) combination.   

ii.

Examining the expressions listed in this problem, we can interpret the expressions as such:

operand ~ 1

e ~ e

esuffix ~ es

operator ~ +

The parse trees for "1 + 1 + 1" can be drawn as such:

```
   First Expression            Second Expression
         e                            e
        /|\                          / \
       e + 1                        1   es
      /|\                               /|\   
     e + 1                             + 1 es
     |                                     /|\    
     1                                    + 1 es
                                               |   
                                            epsilon
```

We can see that these grammars generate the same expressions from the parse trees above.

###3b
Upon reviewing  a couple of test cases of "-" and "<<" usage:

8-2 << 2 = 24 (Since 8-2 = 6 and 6 << 2 equals 24)
8 << 2-1 = 16 (Since to eval to 16, the 2-1 needs to be calculated first, then the shiftted, which means '-' was calculated first)

A scala expression that can test the precedence can be written below:
```scala
val expr = 8-2 << 2 
if(expr == ((8-2)<<2)
   println("Minus takes precedence")
else
   println("Left shift takes precedence")
```   
The result of this scala expression prints "Minus takes precedence" since the '-' takes more precedence than the left shift operator, thus we can conclude that the '-' operator has higher precedence than the '<<' operator.


###3c
```Markdown
S ::= NA.AE
N ::= - | ε       <- N stands for whether the first term is negative or not, it returns the sign if it is, and returns empty if not
A ::= TA | 0T | ε <- A stands for the first term, it can not lead with 0 because T only goes from 1-9, and if it is all 0 it returns                          empty
T ::= 1 | 2 | 3 | ... | 9
E ::= 'E'NTA | ε    <- E stands for the exponent, and the following nonterminals help create the last term.
```
